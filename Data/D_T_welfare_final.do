/**********************************************************************************************
D_T_welfare_final.do

This program performs the welfare calcualtions/counter factuals for Duranton and Turner RES 2012

It relies on data generated by D_T_RES2012_main.do, so this program should be run first.

Table 5 from the paper appears in the log file/display.

mt Dec 2011


************************************************************************************************/
#delimit;

clear all;

clear;

set matsize 800;
set memory 200m;
set more 1;
quietly capture log close;
log using D_T_welfare_final, text replace;


******************************;
*create data set containing parameter estimates and initial employment and roads;
******************************;
do cull_welfare2;

******************************;
*set parameter values for welfare calculations;
******************************;
*agglomeration;
local sigma = 0.03;
*land rent consumption share;
local beta  = 0.032;
* share of transportation;
local alpha = 0.13;
*social discount factor =;
local rho = 1/1.05;
*w  =mean earnings per worker for 1979, from 1980 statistical abstract, 
* adjusted to 2007 dollars, rounded up to nearest 1000, ;
local w =  32000;
*delta;
local delta = 0.06;
*local delta = 0.09;

*phi;
local phi = 0.7;
*local phi = 1.7;

*per kilometer road cost by city size;
gen p_R = cond(exp(l_pop80)<200000, 1300000,
		cond(exp(l_pop80)<1000000, 1700000,3250000));
*city size class catgorical variable;
gen size_class = cond(exp(l_pop80)<200000, 1,
		cond(exp(l_pop80)<1000000, 2,3));


******************************;
*set initial road and population values for status quo and alternative policies;
******************************;

*************** Policy 0(status quo);
*make initial roads and pop for status quo -- renaming to make looping easier later;
gen l_R_0_0 = l_rd_km_IH_83;
gen l_N_0_0 = l_emp83;

*************** Policy 1;
*calculate initial roads for policy 1 - 4.8% increase of 83 initial stock;
gen l_R_0_1 = l_rd_km_IH_83 + log(1.048);
gen l_N_0_1 = l_emp83;

*************** Policy 2;
*calculate total spending on roads under policy 1;
gen  D_R = 0.048 * exp(l_rd_km_IH_83);
*costD_R is period 99 PV of road costs;
gen costD_R = (p_R*D_R)*(1- `rho'^100)/(1-`rho'); 
egen tot_costD_R = total(costD_R);
drop D_R  costD_R;

*calculate initial roads for policy 2 -- same spending as policy 1 allocated per1980 person;
gen pop80=exp(l_pop80);
egen tot_pop80 = total(pop80);	
gen share_pop80 = pop80/tot_pop80;
gen D_rd_km_IH_83 = (share_pop80*tot_costD_R)/(p_R*(1- `rho'^100)/(1-`rho'));
gen l_R_0_2 = log(exp(l_rd_km_IH_83) + D_rd_km_IH_83);
gen l_N_0_2=l_emp83;
*drop tot_pop80 share_pop80 tot_pop80 D_rd_km_IH_83;

*************** Policy 3;
*calculate initial roads for policy 3 -- same spending as policy 1 allocated per capita to bottom half of roads per capita;
gen rd_km_IH_83 =exp(l_rd_km_IH_83);
gen rd_per_capita83= rd_km_IH_83/pop80;
sort rd_per_capita83;
gen pop80_3 = cond(_n<126,pop80,0);
egen tot_pop80_3 = total(pop80_3);
gen share_pop80_3 = pop80_3/tot_pop80_3;
gen D_rd_km_IH_83_3 = (share_pop80_3*tot_costD_R)/(p_R*(1- `rho'^100)/(1-`rho'));
gen l_R_0_3 = log(exp(l_rd_km_IH_83) + D_rd_km_IH_83_3);
gen l_N_0_3=l_emp83;

*clean up;
keep  	msa l_N* l_R* Dl_emp_const Dl_rd_km_const 
	b_l_rd_km_IH_83 b_l_emp83 c_l_rd_km_IH_83 c_l_emp83 
	p_R size_class tot_costD_R;	

**************************************************************************;
*generate  projected roads and pop for each of four policies;
*************************************************************;
*loop through policies;
foreach policy in 0 1 2 3{;	
	*loop through 20 year increments;
	foreach pair in "20 0" "40 20" "60 40" "80 60" "100 80" {;
		local year1 =word("`pair'",1);
		local year0 =word("`pair'",2);

		*generate predicted roads and employment for year1;
		*these two equations are roads and pop estimating equations with LHS in levels;
		gen double l_N_`year1'_`policy' = 	l_N_`year0'_`policy' + 
						Dl_emp_const + 
						b_l_rd_km_IH_83 * l_R_`year0'_`policy' + 
						b_l_emp83 * l_N_`year0'_`policy';
		gen double l_R_`year1'_`policy'= 	l_R_`year0'_`policy' + 
						Dl_rd_km_const + 
						c_l_rd_km_IH_83 * l_R_`year0'_`policy' + 
						c_l_emp83 * l_N_`year0'_`policy';
		*fill in `in between years' with linear interpolation between predicted 20 year values;
		display "counting";
		forvalues t_counter= 1(1)19{;
			local t=`t_counter' + `year0';
			local t_1=`t'-1;
			gen double l_N_`t'_`policy'= l_N_`year0'_`policy' + (`t_counter'*0.05)*(l_N_`year1'_`policy'-l_N_`year0'_`policy');
			gen double l_R_`t'_`policy'= l_R_`year0'_`policy' + (`t_counter'*0.05)*(l_R_`year1'_`policy'-l_R_`year0'_`policy');
			};
		};
	};

*don't need these anymore;
drop  Dl_emp_const-c_l_emp83;

*************************************************************;
*reshape data by year and policy;
*************************************************************;
sort msa;
reshape long 
		l_R_0_ l_N_0_ 		l_R_1_ l_N_1_ 		l_R_2_ l_N_2_ 		l_R_3_ l_N_3_ 
		l_R_4_ l_N_4_ 		l_R_5_ l_N_5_ 		l_R_6_ l_N_6_ 		l_R_7_ l_N_7_ 
		l_R_8_ l_N_8_ 		l_R_9_ l_N_9_ 		l_R_10_ l_N_10_		l_R_11_ l_N_11_ 
		l_R_12_ l_N_12_		l_R_13_ l_N_13_		l_R_14_ l_N_14_		l_R_15_ l_N_15_ 
		l_R_16_ l_N_16_		l_R_17_ l_N_17_		l_R_18_ l_N_18_		l_R_19_ l_N_19_ 
		l_R_20_ l_N_20_		l_R_21_ l_N_21_		l_R_22_ l_N_22_		l_R_23_ l_N_23_ 
		l_R_24_ l_N_24_		l_R_25_ l_N_25_		l_R_26_ l_N_26_		l_R_27_ l_N_27_ 
		l_R_28_ l_N_28_		l_R_29_ l_N_29_		l_R_30_ l_N_30_		l_R_31_ l_N_31_ 
		l_R_32_ l_N_32_		l_R_33_ l_N_33_		l_R_34_ l_N_34_		l_R_35_ l_N_35_ 
		l_R_36_ l_N_36_		l_R_37_ l_N_37_		l_R_38_ l_N_38_		l_R_39_ l_N_39_ 
		l_R_40_ l_N_40_		l_R_41_ l_N_41_		l_R_42_ l_N_42_		l_R_43_ l_N_43_ 
		l_R_44_ l_N_44_		l_R_45_ l_N_45_		l_R_46_ l_N_46_		l_R_47_ l_N_47_ 
		l_R_48_ l_N_48_		l_R_49_ l_N_49_		l_R_50_ l_N_50_		l_R_51_ l_N_51_ 
		l_R_52_ l_N_52_		l_R_53_ l_N_53_		l_R_54_ l_N_54_		l_R_55_ l_N_55_ 
		l_R_56_ l_N_56_		l_R_57_ l_N_57_		l_R_58_ l_N_58_		l_R_59_ l_N_59_ 
		l_R_60_ l_N_60_		l_R_61_ l_N_61_		l_R_62_ l_N_62_		l_R_63_ l_N_63_ 
		l_R_64_ l_N_64_		l_R_65_ l_N_65_		l_R_66_ l_N_66_		l_R_67_ l_N_67_ 
		l_R_68_ l_N_68_		l_R_69_ l_N_69_		l_R_70_ l_N_70_		l_R_71_ l_N_71_ 
		l_R_72_ l_N_72_		l_R_73_ l_N_73_		l_R_74_ l_N_74_		l_R_75_ l_N_75_ 
		l_R_76_ l_N_76_		l_R_77_ l_N_77_		l_R_78_ l_N_78_		l_R_79_ l_N_79_ 
		l_R_80_ l_N_80_		l_R_81_ l_N_81_		l_R_82_ l_N_82_		l_R_83_ l_N_83_ 
		l_R_84_ l_N_84_		l_R_85_ l_N_85_		l_R_86_ l_N_86_		l_R_87_ l_N_87_ 
		l_R_88_ l_N_88_		l_R_89_ l_N_89_		l_R_90_ l_N_90_		l_R_91_ l_N_91_ 
		l_R_92_ l_N_92_		l_R_93_ l_N_93_		l_R_94_ l_N_94_		l_R_95_ l_N_95_ 
		l_R_96_ l_N_96_		l_R_97_ l_N_97_		l_R_98_ l_N_98_		l_R_99_ l_N_99_ 
		l_R_100_ l_N_100_ 
		, i(msa)	j(policy);
local T=0 ;

while `T'<=100{ ;
	rename l_R_`T'_ l_R_`T';
	rename l_N_`T'_ l_N_`T';
	local T = `T'+1  ;
	};

sort msa policy;
	

reshape long l_R_ l_N_ 
		, i(msa policy)	j(year);
rename  l_R_ l_R;
rename  l_N_ l_N;

*get levels from logs;
gen R=exp(l_R);
gen N=exp(l_N);
drop l_R l_N;


*reshape back to wide by policy;
sort msa year policy;
reshape wide R N, i(msa year) j(policy);
foreach policy in 0 1 2 3{;
	label var R`policy' "km IH policy `policy'";
	label var N`policy' "employment  policy `policy'";
	};

*************************************************************;
*welfare calculations by msa year;
*************************************************************;

rename year t;

*calculate EV of moving from policy 0 to k for each period and msa;
sort msa;
foreach k in 0 1 2 3{;
	*EV by t and msa - calculation verified in spreadsheet, 052711;
	gen EV`k' =
		`w'* N0^`sigma' *(
					(R`k'/R0)^(`delta'*(`alpha'+`beta'*`phi')/(`delta'+1) ) 
						*
					(N0/N`k')^(
							(
							`alpha'*`delta'*(`sigma'+1) +
							(`beta'-1)*`sigma'*(`delta'+1)-
							`beta'*`phi'*(`sigma'-`delta')
					           	)
					           	/
					           	(`delta'+1)
					           )							
					 -    1            
				);
	*change in per employee land rent by year and city - calculation verified in spreadsheet, 052711;
	gen D_pi`k' = `beta'*`w'*(N`k'^`sigma' - N0^`sigma');
	*change in per empoyee road costs by year and city - calculation verified in spreadsheet, 052711;
	gen D_c`k' = p_R*(R`k'- R0)/N0;
	*change in per capita welfare by city year - calculation verified in spreadsheet, 052711;
	gen D_Omega`k' = EV`k'+D_pi`k' - D_c`k';
	by msa:gen initial_N`k' = N`k' if _n==1;
	by msa:gen final_N`k' = N`k' if _n==101;
	by msa:gen initial_R`k' = R`k' if _n==1;
	by msa:gen final_R`k' = R`k' if _n==101;
	};
drop N* R*;
*discount each year's EV,D_pi,DC back to zero;
foreach k in 0 1 2 3{;
	gen PV_EV`k' = (`rho'^t)*EV`k';
	gen PV_D_pi`k' = (`rho'^t)*D_pi`k';
	gen PV_D_c`k' =(`rho'^t)*D_c`k';
	gen PV_D_Omega`k' =(`rho'^t)*D_Omega`k';
	*don't need these anymore;
	drop EV`k' D_pi`k' D_c`k' D_Omega`k';
	};


*sum discount PV - calculation verified in spreadsheet, 052711;	
sort msa t;

collapse (mean) size_class (mean)initial_N0-final_R3 (sum)PV_EV0-PV_D_Omega3 , by(msa);

*data set in memory has welfare calcualtions by city;
save welfare_by_msa,replace;

*reshape long by policy for tables;
sort msa size;
reshape long   initial_N final_N initial_R final_R PV_EV PV_D_pi PV_D_c PV_D_Omega, i(msa size) j(policy);
gen pct_D_N = (((final_N/initial_N))^0.01-1)*100;
*make output table;
replace initial_N=int(initial_N);
table size policy [fw=initial_N], c(mean pct_D_N mean PV_EV  mean PV_D_pi mean PV_D_c mean PV_D_Omega) row format(%9.2f);
log close;
exit;